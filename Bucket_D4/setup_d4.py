import numpy as np
import laurent

# D4 as generated by the Cartan Type
# Oriented version

#####################
#           O 4     #
#           |       #
#           |       #
#      O--->O--->O  #
#      1    2    3  #
# D4                #
#####################
## Careful: the middle node has label 2!

positive_letters = [1,2,3,4]
negative_letters = [-1,-2,-3,-4]
all_letters = positive_letters + negative_letters
restricted_letters = all_letters
coxeter_matrix = np.array([[1,3,2,2],[3,1,3,3],[2,3,1,2],[2,3,2,1]])
dynkin_graph = {1: set([2]), 2: set([1,3,4]), 3: set([2]), 4: set([2])}
dynkin_ograph={1:set([2]), 2: set([3,4]), 3:set([]), 4:set([])}

# Careful, the function below is coded with nodes labeled from 1. Later in some of the dictionaries the entries start from 0
def exists_dynkin_graph_edge(i,j):
    if j in dynkin_graph.get(i, set()):
        return True
    else:
        return False
def exists_dynkin_ograph_edge(i,j):
    if j in dynkin_ograph.get(i, set()):
        return True
    else:
        return False

# In type A, we were classifying the curves according to their ends. This amounts to computing their associated root.

a1=np.array([1,0,0,0])
a2=np.array([0,1,0,0])
a3=np.array([0,0,1,0])
a4=np.array([0,0,0,1])
alpha=[a1,a2,a3,a4]

def makekey(root,nb):
    key_tuple = (root[0],root[1],root[2],root[3],nb)
    return '-'.join([str(x) for x in key_tuple])

ROOTS=[a1, a2, a3, a4,
       a1 + a2, a2 + a3, a2 + a4,
       a1 + a2 + a3, a1 + a2 + a4, a2 + a3 + a4,
       a1 + a2 + a3 + a4,
       a1 + 2*a2 + a3 + a4]

###################################
# END OF D4-specific definitions  #
###################################

## Everything beyond this point should go through for any cartan type after suitable modifications above.

def make_burau_fn(i):
    """
    Returns the "ith Burau matrix" function.

    More precisely, it returns a function ``f`` that takes in a vector ``v`` of Laurent polynomial dictionaries, and outputs a vector of Laurent polynomial dictionaries, indexed by the vertices in the Dynkin graph.
    The vector ``f(v)`` is the output of the action of the ith Burau matrix on the vector of Laurent polynomials represented by v.

    INPUT:
    - ``i``, a positive or negative letter of the chosen Cartan type.

    OUTPUT:
    A function ``f`` that takes in a vector ``v`` of Laurent polynomial dictionaries and returns another vector of Laurent polynomial dictionaries, such that ``f(v)`` is the output of the linear action of the ith Burau matrix on ``v``.
    """
    
    # Record the sign of i; the Burau matrix depends on whether we have a letter or an inverse letter.
    i_sgn = -1 if i < 0 else 1

    # Matrices are zero-indexed, hence the following.
    index = abs(i) - 1

    def burau_fn_i(input_vec):
        """
        Given an input vector of Laurent polynomial dictionaries, returns an output vector consisting of the ith Burau matrix applied to it.

        Note that only the entry at coordinate ``index`` of the input vector changes in this situation, so that is the only one we update.
        """
        updated_coordinate = {}
        for k in range(0, len(input_vec)):
            kth_summand = {}
            
            if k == index:
                # In this case, the [index,k]th entry of the Burau matrix is precisely
                # -q^(-2) if i > 0 and q^2 if i < 0.
                kth_summand = laurent.product({-2*i_sgn : -1}, input_vec[k])

            elif coxeter_matrix[index, k] > 2:
                # In this case, the [index, k]th entry of the Burau matrix is precisely
                # -q^(-1) if i > 0 and -q if i < 0.
                kth_summand = laurent.product({-1*i_sgn : -1}, input_vec[k])
            else:
                # In all other cases, the [index, k]th entry of the Burau matrix is zero.
                # We represent this by an empty dictionary.
                kth_summand = {}

            updated_coordinate = laurent.trim(laurent.addition(updated_coordinate, kth_summand))

        output_vec = input_vec.copy()
        output_vec[index] = updated_coordinate
        return output_vec

    return burau_fn_i


# Oriented version
def make_oburau_fn(i):
    """
    Returns the "ith Burau matrix" function with the orientation grading conventions.

    More precisely, it returns a function ``f`` that takes in a vector ``v`` of Laurent polynomial dictionaries, and outputs a vector of Laurent polynomial dictionaries, indexed by the vertices in the Dynkin graph.
    The vector ``f(v)`` is the output of the action of the ith Burau matrix on the vector of Laurent polynomials represented by v.

    INPUT:
    - ``i``, a positive or negative letter of the chosen Cartan type.

    OUTPUT:
    A function ``f`` that takes in a vector ``v`` of Laurent polynomial dictionaries and returns another vector of Laurent polynomial dictionaries, such that ``f(v)`` is the output of the linear action of the ith Burau matrix on ``v``.
    """
    
    # Record the sign of i; the Burau matrix depends on whether we have a letter or an inverse letter.
    i_sgn = -1 if i < 0 else 1

    # Matrices are zero-indexed, hence the following.
    index = abs(i) - 1

    def oburau_fn_i(input_vec):
        """
        Given an input vector of Laurent polynomial dictionaries, returns an output vector consisting of the ith Burau matrix applied to it.

        Note that only the entry at coordinate ``index`` of the input vector changes in this situation, so that is the only one we update.
        """
        updated_coordinate = {}
        for k in range(0, len(input_vec)):
            kth_summand = {}
            
            if k == index:
                # In this case, the [index,k]th entry of the Burau matrix is precisely
                # -q^(-1) if i > 0 and q if i < 0.
                kth_summand = laurent.product({-i_sgn : -1}, input_vec[k])

            elif coxeter_matrix[index, k] > 2:
                # In this case, the [index, k]th entry of the Burau matrix is precisely
                # -q^(-1) if i > 0  and index <-- k,
                # -1 if i >0 and index-->k,
                # -q if i < 0 and index --> k,
                # -1 if i < 0 and index <-- k
                if exists_dynkin_ograph_edge(index+1,k+1) :
                    if i>0 :
                        kth_summand = laurent.product({0 : -1},input_vec[k])
                    if i<0 :
                        kth_summand = laurent.product({-1*i_sgn : -1},input_vec[k])
                if exists_dynkin_ograph_edge(k+1,index+1) :
                    if i>0 :
                        kth_summand = laurent.product({-1*i_sgn : -1}, input_vec[k])
                    if i<0 :
                        kth_summand = laurent.product({0:-1},input_vec[k])
            else:
                # In all other cases, the [index, k]th entry of the Burau matrix is zero.
                # We represent this by an empty dictionary.
                kth_summand = {}

            updated_coordinate = laurent.trim(laurent.addition(updated_coordinate, kth_summand))

        output_vec = input_vec.copy()
        output_vec[index] = updated_coordinate
        return output_vec

    return oburau_fn_i



def make_pi_dim_vector(i):
    """
    Helper function to create the dimension vector (with Laurent polynomial dictionary entries) of the ith indecomposable projective Pi.

    INPUT:
    - ``i`` a positive letter of the chosen Cartan type.

    OUTPUT:
    - A list whose ith entry is the dictionary {0:1} and all other entries are {}.
    This corresponds to the fact that the dimension vector of Pi is 1 in the ith coordinate and zero in all other coordinates.
    """
    output_vec = [{} for _ in range(len(dynkin_graph))]
    output_vec[i - 1] = {0 : 1}
    return output_vec

# Final outputs of this setup.
burau_fns = {i : make_burau_fn(i) for i in all_letters}
dim_vectors = {i : make_pi_dim_vector(i) for i in positive_letters}
oburau_fns = {i : make_oburau_fn(i) for i in all_letters}


# # Now to pre-compile functions for more generators

# def make_oburau_gen(gen) :
#     """
#     Takes a generator (typically, a dual generator), and returns the associated Burau function. To speed up the process, we first compute the image of the basis vectors, 
#     and use these computations to code the function itself.
#     """
#     outvectors=[dim_vectors[i] for i in dim_vectors.keys()]
#     for x in reversed(gen) :
#         outvectors=[oburau_fns[x](vect) for vec in outvectors]
#     def make_oburau_gen_gen(entry) :
#         # first computing the contribution of the e_1 coordinate in entry
#         out=[laurent.product(entry[0],outvectors[0][k]) for k in range(len(outvectors[0]))]
#         # then adding all other contributions one at a time
#         for index in range(1 : len(entry)) :
#             out=[laurent.addition(out[k],laurent.product(entry[k],outvectors[index][k])) for k in range(len(outvectors[index])))
#         return out
#     return make_oburau_gen_gen
            

def pairing(dim_vec1,dim_vec2):
    """
    Given two dimension vectors with entries Laurent polynomials dictionaries, returns the pairing.
    
    INPUT:
    - dim_vec1, dim_vec2: 2 dimension vectors
    
    OUTPUT:
    - a Laurent polynomial dictionary that gives the q-pairing
    """
    total_sum = {}
    for i in range(len(dim_vec1)):
        fi = laurent.qtoqinv(dim_vec1[i])
        tmp_sum = {}
        for j in range(len(dim_vec2)):
            gj = dim_vec2[j]
            if j == i:
                # Add (1+q^2) * gj to the intermediate sum if j = i
                tmp_sum = laurent.addition(tmp_sum, laurent.product({0:1,2:1}, gj))
            elif exists_dynkin_graph_edge(i+1,j+1):
                # Add q * gj to the intermediate sum if j - i is an edge
                tmp_sum = laurent.addition(tmp_sum, laurent.product({1:1}, gj))
        total_sum = laurent.addition(total_sum, laurent.product(fi, tmp_sum))
        
    return laurent.trim(total_sum)

def opairing(dim_vec1,dim_vec2):
    """
    Given two dimension vectors with entries Laurent polynomials dictionaries, returns the pairing.
    
    INPUT:
    - dim_vec1, dim_vec2: 2 dimension vectors
    
    OUTPUT:
    - a Laurent polynomial dictionary that gives the q-pairing
    """
    total_sum = {}
    for i in range(len(dim_vec1)):
        fi = laurent.qtoqinv(dim_vec1[i])
        tmp_sum = {}
        for j in range(len(dim_vec2)):
            gj = dim_vec2[j]
            if j == i:
                # Add (1+q) * gj to the intermediate sum if j = i
                tmp_sum = laurent.addition(tmp_sum, laurent.product({0:1,1:1}, gj))
            elif exists_dynkin_graph_edge(i+1,j+1):
                if exists_dynkin_ograph_edge(i+1,j+1) :
                    # Add 1 or q  * gj to the intermediate sum if j - i is an edge
                    tmp_sum = laurent.addition(tmp_sum, laurent.product({1:1}, gj))
                else :
                    tmp_sum = laurent.addition(tmp_sum, laurent.product({0:1},gj))
        total_sum = laurent.addition(total_sum, laurent.product(fi, tmp_sum))
        
    return laurent.trim(total_sum)

# Utilities to manipulate dimension vectors.
def poly_normalize_vector(dim_vec):
    """
    Function to normalize a dimension vector of Laurent polynomial dictionaries.
    The normalized dimension vector has its lowest degree q-polynomial set at degree zero, with leading coefficient positive.

    INPUT:
    - ``dim_vec``, a dimension vector whose entries are Laurent polynomial dictionaries. So each entry is a dictionary of the form {deg : coeff}.

    OUTPUT:
    - A normalized dimension vector as explained above.
    """
    bottom_deg, min_index = np.inf, None
    new_deg = np.inf

    for k in range(len(dim_vec)):
        if dim_vec[k] == {}:
            new_valuation = np.inf
        else:
            new_valuation = min(dim_vec[k].keys())

        if new_valuation < bottom_deg:
            bottom_deg, min_index = new_valuation, k

    if min_index is not None:
        leading_coeff_index = max(dim_vec[min_index].keys())
        leading_coeff = dim_vec[min_index][leading_coeff_index]
        sgn = 1 if leading_coeff >= 0 else -1
        q_factor = {-bottom_deg : sgn}

        return [laurent.product(q_factor, d) for d in dim_vec]
    else:
        return dim_vec

def find_ends_vector(dim_vec):
    """
    Given a dimension vector with entries Laurent polynomials dictionaries, returns the associated root.
    
    INPUT:
    - ``dim_vec`` a dimension vector
    OUTPUT:
    - an array that represents the associated root in terms of coordinates in the ai's.
    """
    dequantized_dim_vec=[laurent.dequantize(d) for d in dim_vec]
    return sum([abs(dequantized_dim_vec[i])*alpha[i] for i in range(len(alpha))])

def nb_terms_vector(dim_vec):
    """
    Given a dimension vector with entries Laurent polynomials dictionaries, returns the number of "terms" in it.
    
    INPUT:
    - ``dim_vec`` a dimension vector
    OUTPUT:
    - an array that represents the associated root in terms of coordinates in the ai's.
    """
    return sum([sum([abs(v) for v in d.values()]) for d in dim_vec])

def topdeg_vector(dim_vec):
    """
    Given a dimension vector with entries Laurent polynomials dictionaries, returns the top degree.
    
    INPUT:
    - ``dim_vec`` a dimension vector
    OUTPUT:
    - Either an integer or -infinity.
    """
    return max([laurent.degree(x) for x in dim_vec])

def botdeg_vector(dim_vec):
    """
    Given a dimension vector with entries Laurent polynomials dictionaries, returns the bottom degree.
    
    INPUT:
    - ``dim_vec`` a dimension vector
    OUTPUT:
    - Either an integer or +infinity.
    """
    return min([laurent.valuation(x) for x in dim_vec])

# Helper function to convert to/from json correctly. TODO update in a better way.
def dim_vector_cleanup(dim_vec):
    new_dim_vec = []
    for d in dim_vec:
        new_d = {int(k):v for (k,v) in d.items()}
        new_dim_vec.append(new_d)
    return new_dim_vec

# Helper function to convert to/from json correctly. TODO update in a better way.
def dim_vector_cleanup_lkb(dim_vec):
    new_dim_vec = []
    for d in dim_vec:
        new_d = {int(k): {int(l) : w} for (k,v) in d.items() for (l,w) in v.items()}
        new_dim_vec.append(new_d)
    return new_dim_vec

def json_dictionaries_cleanup(d):
    for k in d:
        v = d[k]
        new_v = [[x[0],x[1],dim_vector_cleanup(x[2])] for x in v]
        d[k] = new_v
    return d

# Apparently in the case of a dictionary with entries, dictionaries, only the first entry gets saved. Let's disassemble dictionaries and make them into lists before saving them

def disassemble(d) :
    aux_list=[]
    for key1 in d.keys() :
        for key2 in d[key1] :
            aux_list.append([key1,key2,d[key1][key2]])
    return aux_list

def disassemble_vector(vec) :
    return [disassemble(d) for d in vec]



def reassemble(aux_list) :
    dic={}
    for [key1,key2,coeff] in aux_list :
        if key1 in dic.keys() :
            if key2 in dic[key1].keys() :
                raise Exception("The same monomial appeared more than once.")
            dic[key1][key2]=coeff
        else :
            dic[key1]={key2 : coeff}
    return dic

def reassemble_vector(veclist) :
    return [reassemble(aux_list) for aux_list in veclist]





